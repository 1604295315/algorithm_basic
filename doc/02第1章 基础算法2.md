# 第一章 基础算法(二)

## 快速排序
i j 互换
segment fault
边界问题
与取得边界值相关
C++ sort 快排和插排的组合
```C++
quick_sort(q, l, r);
quick_sort(q, l, r);
```

## 高精度
*  C++ 需要 
* Java Python不需要

1. 两个大整数相加 1e6
2. 两个大整数相减 1e6
3. 相乘
4. 想除

big decimal
* 大整数存储 数组 int[0] = 个位 小端
* 模拟全加器
* 压位 ?

* 减法


## 前缀和与差分
---
前缀和 和 差分是 一对 逆运算
### 前缀和 (前缀和数组)
$ S_i = a_1 + a_2 + ... + a_i $
#### 如何求$s_i$
```C++
s[0] = 0;
for (int i = 0; i <= n; i ++>)
    s[i] = s[i-1] + a[i];
```
#### 作用
快速地求出原数组中一段数的和。
例如 r,l 这几个数的和`x = s[r] - s[l - 1]`

---
#### 一维前缀和 
```
S[i] = a[1] + a[2] + ... a[i]

a[l] + ... + a[r] = S[r] - S[l - 1]
```
---
#### 二维前缀和 
```
S[i, j] = 第i行j列格子左上部分所有元素的和

以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

---
### 差分
#### 概念
    $ a_1 a_2 a_3 ... a_n $ //前缀和

    构造$ b_1 b_2 b_3 ... b_n $ //差分

    使得$ a_i = b_1 + b_2 + b_3 + ... + b_i $

    称a为b的前缀和; b为a的差分

$$
    b_1 = a_1;

    b_2 = a_2 - a_1;

    ...
    
    b_i = a_i - a_i-1;
$$
---
#### 作用

  O(n) 由B->A
  a[l,r] + c
    暴力: O(n)
    差分: O(1)
      b[l] + c
      b[r + 1] -c

      a[l] = b[l] - b[l - 1]
      a[r] = b[r] - b[r - 1]
      a[r + 1] = b[r + 1] - b[r]
线段树 = 前缀和 + 差分


---
#### 一维差分

```
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

---

#### 二维差分

```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
---------- 
end